name: template_update

on:
  workflow_call:
    inputs:
      template_repo:
        description: 'URL of the cookiecutter template repo'
        required: true
        type: string
      repo_branch:
        description: 'Branch of the project repo to update'
        required: true
        type: string

jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    outputs:
      repo:   ${{ inputs.template_repo }}
      branch: ${{ inputs.repo_branch }}
    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all remote branches
        run: |
          git fetch origin '+refs/heads/*:refs/remotes/origin/*'

      - name: Validate repo_branch exists
        run: |
          if ! git show-ref --verify --quiet "refs/remotes/origin/${{ inputs.repo_branch }}"; then
            echo "::error ::Branch '${{ inputs.repo_branch }}' not found!"
            exit 1
          fi

  update-template:
    needs: validate-inputs
    runs-on: ubuntu-latest
    steps:
      # 1. Check out the target branch
      - name: Checkout project at ${{ needs.validate-inputs.outputs.branch }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.validate-inputs.outputs.branch }}

      # 2. Set up Python & Cookiecutter
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - run: pip install cookiecutter jq
      
      # this section checks if the template has had updates
      
      # 3. Grab old & new template SHAs checks template changes
      - name: Read old template SHA
        id: get_old_sha
        run: |
          OLD_SHA=$(jq -r '.template_sha' .cookiecutter.json)
          echo "old_sha=$OLD_SHA" >> $GITHUB_OUTPUT
      - name: Fetch new template SHA
        id: get_new_sha
        run: |
          NEW_SHA=$(git ls-remote "${{ needs.validate-inputs.outputs.repo }}" HEAD | cut -f1)
          echo "new_sha=$NEW_SHA" >> $GITHUB_OUTPUT

      # 4. Clone base & new template repos
      - name: Clone base template at old SHA
        run: |
          git clone "${{ needs.validate-inputs.outputs.repo }}" base-template
          pushd base-template
            git checkout "${{ steps.get_old_sha.outputs.old_sha }}"
          popd

      - name: Clone new template at HEAD
        run: git clone "${{ needs.validate-inputs.outputs.repo }}" template-source

      # 5. Determine which sub-template to use
      - name: Determine sub-template path
        id: template_path
        run: |
          if grep -q '"is_aspire": *"yes"' .cookiecutter.json; then
            echo "path=aspire-project" >> $GITHUB_OUTPUT
          elif grep -q '"is_docker": *"yes"' .cookiecutter.json; then
            echo "path=docker-project" >> $GITHUB_OUTPUT
          else
            echo "::error ::No valid sub-template selected!" && exit 1
          fi

      # 6. Regenerate base & new outputs
      - name: Generate base template output
        run: |
          mkdir -p template-base
          cookiecutter "base-template/${{ steps.template_path.outputs.path }}" \
            --no-input --replay-file .cookiecutter.json \
            --output-dir template-base

      - name: Generate new template output
        run: |
          mkdir -p template-new
          cookiecutter "template-source/${{ steps.template_path.outputs.path }}" \
            --no-input --replay-file .cookiecutter.json \
            --output-dir template-new

      # 7. Create a unified patch
      - name: Create update.patch
        run: |
          diff -ruN \
            template-base/${{ steps.template_path.outputs.path }} \
            template-new/${{ steps.template_path.outputs.path }} \
            > update.patch || true

      # 8. Apply it with three-way merge
      - name: Apply three-way merge
        run: |
          if ! git apply --index --3way update.patch; then
            echo "::error ::Merge conflicts detected in template updates – exiting."
            exit 1
          fi

      # 9. Update the SHA in .cookiecutter.json
      - name: Write new SHA back to .cookiecutter.json
        run: |
          jq --arg sha "${{ steps.get_new_sha.outputs.new_sha }}" \
             '.template_sha = $sha' .cookiecutter.json > tmp.json
          mv tmp.json .cookiecutter.json
          git add .cookiecutter.json

      # 10. Clean up temp dirs
      - name: Cleanup
        run: rm -rf base-template template-source template-base template-new update.patch

      # 11. Commit & push merged result on a new branch
      - name: Commit & push
        id: commit
        run: |
          BRANCH="template-update-${{ steps.get_new_sha.outputs.new_sha }}"
          echo "UPDATE_BRANCH=$BRANCH" >> $GITHUB_ENV
          git checkout -b "$BRANCH"
          git commit -m "chore: merge template ${ steps.get_old_sha.outputs.old_sha } → ${ steps.get_new_sha.outputs.new_sha }"
          git push origin "$BRANCH"

      # 12. Open a single draft PR
      - name: Create draft Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ env.UPDATE_BRANCH }}
          base:   ${{ needs.validate-inputs.outputs.branch }}
          draft:  true
          title:  "chore: merge cookiecutter template updates"
          body: |
            **Template Repo:** ${{ needs.validate-inputs.outputs.repo }}  
            **Base SHA:**      ${{ steps.get_old_sha.outputs.old_sha }}  
            **New  SHA:**      ${{ steps.get_new_sha.outputs.new_sha }}  
